<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>DEATH.RUN — Escape Hell</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Creepster&family=Press+Start+2P&display=swap');
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #000;
    overflow: hidden;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    font-family: 'Press Start 2P', monospace;
  }
  #wrap { position: relative; }
  canvas {
    display: block;
    border: 2px solid #ff0033;
    box-shadow: 0 0 60px rgba(255,0,51,0.4), 0 0 120px rgba(255,0,51,0.15);
  }
  #bloom { position: absolute; top: 0; left: 0; pointer-events: none; mix-blend-mode: screen; opacity: 0.6; }
  #ui-overlay {
    position: absolute; top: 0; left: 0; right: 0; bottom: 0;
    pointer-events: none;
    display: flex; flex-direction: column; align-items: center; justify-content: center;
  }
  #title-screen, #death-screen { pointer-events: auto; text-align: center; color: #ff0033; text-shadow: 0 0 30px rgba(255,0,51,0.9), 0 0 60px rgba(255,0,0,0.4); }
  #title-screen h1 { font-family: 'Creepster', cursive; font-size: 80px; letter-spacing: 10px; animation: flicker 3s infinite; margin-bottom: 10px; }
  #title-screen .subtitle { font-size: 11px; color: #cc0000; margin-bottom: 40px; letter-spacing: 4px; }
  #title-screen .start-prompt { font-size: 14px; color: #ff3366; animation: pulse 1.5s infinite; }
  #death-screen { display: none; }
  #death-screen h2 { font-family: 'Creepster', cursive; font-size: 64px; animation: shake 0.3s infinite; margin-bottom: 20px; }
  #death-screen .stats { font-size: 10px; color: #aa0022; line-height: 2.4; margin-bottom: 30px; }
  #death-screen .restart-prompt { font-size: 12px; color: #ff3366; animation: pulse 1.5s infinite; }
  .hud { position: absolute; top: 18px; left: 0; right: 0; display: none; justify-content: space-between; padding: 0 28px; font-size: 12px; color: #ff0033; text-shadow: 0 0 12px rgba(255,0,51,0.7); }
  .hud .souls { color: #aa00ff; text-shadow: 0 0 12px rgba(170,0,255,0.7); }
  .combo-display { position: absolute; top: 50px; left: 0; right: 0; text-align: center; font-size: 10px; color: #ff6600; text-shadow: 0 0 15px rgba(255,102,0,0.9); display: none; }
  @keyframes flicker { 0%,92%,100%{opacity:1} 93%{opacity:0.3} 94%{opacity:0.8} 95%{opacity:0.2} 96%{opacity:0.9} }
  @keyframes pulse { 0%,100%{opacity:1} 50%{opacity:0.3} }
  @keyframes shake { 0%,100%{transform:translateX(0)} 25%{transform:translateX(-4px) rotate(-1deg)} 75%{transform:translateX(4px) rotate(1deg)} }
</style>
</head>
<body>

<div id="wrap">
  <canvas id="game" width="900" height="650"></canvas>
  <canvas id="bloom" width="900" height="650"></canvas>
  <div id="ui-overlay">
    <div id="title-screen">
      <h1>DEATH.RUN</h1>
      <div class="subtitle">// ESCAPE HELL OR DIE TRYING //</div>
      <div class="start-prompt">[ PRESS SPACE TO DESCEND ]</div>
    </div>
    <div id="death-screen">
      <h2>WASTED</h2>
      <div class="stats">
        <div>DISTANCE: <span id="final-dist">0</span>m INTO THE ABYSS</div>
        <div>SOULS DEVOURED: <span id="final-souls">0</span></div>
        <div>DEMONS DODGED: <span id="final-dodged">0</span></div>
        <div>MAX COMBO: <span id="final-combo">0</span>x</div>
        <div>CAUSE OF DEATH: <span id="death-cause">SKILL ISSUE</span></div>
      </div>
      <div class="restart-prompt">[ SPACE TO SUFFER AGAIN ]</div>
    </div>
    <div class="hud" id="hud">
      <div>DIST: <span id="hud-dist">0</span>m</div>
      <div class="souls">SOULS: <span id="hud-souls">0</span></div>
      <div>SPEED: <span id="hud-speed">0</span></div>
    </div>
    <div class="combo-display" id="combo-display"><span id="combo-text"></span></div>
  </div>
</div>

<script>
// ============================================================
//  DEATH.RUN  —  3D Enhanced Edition
// ============================================================
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const bloomCanvas = document.getElementById('bloom');
const bctx = bloomCanvas.getContext('2d');
const W = 900, H = 650;

// Perspective constants
const HORIZON = 180;        // y-line of the horizon
const FLOOR_TOP = HORIZON;  // where the 3D floor starts
const CEIL_BOT = HORIZON;   // where the 3D ceiling ends
const VP_X = W / 2;         // vanishing point X
const VP_Y = HORIZON;       // vanishing point Y

// ---- state ----
let state = 'title';
let player, obstacles, souls, particles, bgParticles, lightSources;
let distance, soulCount, demonsDodged, combo, maxCombo, speed;
let screenShake = 0, flashAlpha = 0, frameCount = 0;
let lastObstacle = 0, lastSoul = 0, dashCooldown = 0, invincible = 0;
let lavaGlowPhase = 0;

// Parallax mountain layers (pre-generated)
let mountainLayers = [];

function generateMountains() {
  mountainLayers = [];
  for (let layer = 0; layer < 3; layer++) {
    const pts = [];
    const segW = 30 + layer * 20;
    for (let x = 0; x <= W + segW; x += segW) {
      const baseH = 40 + layer * 25;
      pts.push({ x, y: HORIZON - baseH - Math.random() * (50 - layer * 12) });
    }
    mountainLayers.push({ pts, speed: 0.15 + layer * 0.1, offset: 0, color: layer });
  }
}
generateMountains();

// ---- input ----
const keys = {};
document.addEventListener('keydown', e => {
  keys[e.code] = true;
  if (e.code === 'Space') { e.preventDefault(); if (state !== 'playing') startGame(); }
});
document.addEventListener('keyup', e => keys[e.code] = false);
let touchX = null;
canvas.addEventListener('touchstart', e => { e.preventDefault(); touchX = e.touches[0].clientX - canvas.getBoundingClientRect().left; if (state !== 'playing') startGame(); });
canvas.addEventListener('touchmove', e => { e.preventDefault(); touchX = e.touches[0].clientX - canvas.getBoundingClientRect().left; });
canvas.addEventListener('touchend', () => touchX = null);

// ---- helpers ----
function lerp(a, b, t) { return a + (b - a) * t; }
function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }
function rand(a, b) { return a + Math.random() * (b - a); }

// Map a world-y (play area y: 0 = top of play zone, 1 = bottom) to screen position
// The play area is between HORIZON and H. Objects at y=HORIZON are far away, objects at y=H are close.
function worldToScreen(wx, wy) {
  // wy is the raw game y (20..H-35). Map it into the play area.
  const t = (wy - 20) / (H - 55); // 0..1
  const sy = lerp(HORIZON + 20, H - 10, t);
  // Perspective X: objects near horizon converge to VP_X
  const depth = 1 - (sy - HORIZON) / (H - HORIZON); // 1=far, 0=near
  const sx = lerp(wx, VP_X, depth * 0.45);
  const scale = lerp(1.0, 0.25, depth);
  return { sx, sy, scale, depth };
}

// ---- game funcs ----
function startGame() {
  state = 'playing';
  player = { x: 200, y: H / 2 + 50, w: 24, h: 32, vy: 0, trail: [], lean: 0 };
  obstacles = []; souls = []; particles = []; bgParticles = []; lightSources = [];
  distance = 0; soulCount = 0; demonsDodged = 0; combo = 0; maxCombo = 0;
  speed = 3; dashCooldown = 0; invincible = 0; frameCount = 0;
  lastObstacle = 0; lastSoul = 0; lavaGlowPhase = 0;
  generateMountains();
  for (let i = 0; i < 80; i++) {
    bgParticles.push({ x: Math.random() * W, y: Math.random() * H, z: Math.random(), size: rand(1, 3), speed: rand(0.5, 2), alpha: rand(0.1, 0.5), flicker: rand(0, Math.PI * 2) });
  }
  document.getElementById('title-screen').style.display = 'none';
  document.getElementById('death-screen').style.display = 'none';
  document.getElementById('hud').style.display = 'flex';
  document.getElementById('combo-display').style.display = 'block';
}

function die(cause) {
  state = 'dead'; screenShake = 25; flashAlpha = 1;
  for (let i = 0; i < 80; i++) {
    const a = rand(0, Math.PI * 2), s = rand(2, 10);
    particles.push({ x: player.x, y: player.y, vx: Math.cos(a)*s, vy: Math.sin(a)*s, life: rand(40, 100), maxLife: 100, size: rand(2, 6), color: Math.random()>0.5?'#ff0033':'#ff6600', glow: true });
  }
  for (let i = 0; i < 20; i++) {
    const a = rand(0, Math.PI * 2), s = rand(1, 6);
    particles.push({ x: player.x, y: player.y, vx: Math.cos(a)*s, vy: Math.sin(a)*s-3, life: 90, maxLife: 90, size: rand(1, 4), color: '#ccccaa', gravity: true });
  }
  document.getElementById('final-dist').textContent = Math.floor(distance);
  document.getElementById('final-souls').textContent = soulCount;
  document.getElementById('final-dodged').textContent = demonsDodged;
  document.getElementById('final-combo').textContent = maxCombo;
  document.getElementById('death-cause').textContent = cause;
  document.getElementById('hud').style.display = 'none';
  document.getElementById('combo-display').style.display = 'none';
  setTimeout(() => { document.getElementById('death-screen').style.display = 'block'; }, 800);
}

// ---- obstacle types ----
const OBSTACLE_TYPES = [
  { name: 'HELLFIRE PILLAR', color: '#ff2200', w: 30, h: 80, pattern: 'pillar' },
  { name: 'DEMON SKULL', color: '#ff0066', w: 44, h: 44, pattern: 'skull' },
  { name: 'BONE SAW', color: '#ccccaa', w: 50, h: 20, pattern: 'saw' },
  { name: 'LAVA GEYSER', color: '#ff6600', w: 25, h: 120, pattern: 'geyser' },
  { name: 'BLOOD SPIKE', color: '#990022', w: 15, h: 65, pattern: 'spike' },
  { name: 'CHAIN WHIP', color: '#888888', w: 200, h: 8, pattern: 'chain' },
];

function spawnObstacle() {
  const diff = Math.min(distance / 500, 1);
  const count = 1 + (Math.random() < diff ? 1 : 0);
  for (let i = 0; i < count; i++) {
    const type = OBSTACLE_TYPES[Math.floor(Math.random() * OBSTACLE_TYPES.length)];
    const o = { x: W + 60 + i * 130, y: rand(HORIZON + 60, H - 60), w: type.w, h: type.h, type, angle: 0, sinOffset: rand(0, Math.PI*2), passed: false };
    if (type.pattern === 'saw') o.vy = (Math.random()>0.5?1:-1) * (2 + diff*2.5);
    else if (type.pattern === 'chain') o.y = rand(HORIZON + 80, H - 80);
    else if (type.pattern === 'skull') o.homing = diff > 0.4 && Math.random() > 0.5;
    obstacles.push(o);
  }
}

function spawnSoul() {
  souls.push({ x: W + 20, y: rand(HORIZON + 60, H - 60), size: 14, pulse: 0, collected: false });
}

// ============================================================
//  3D DRAWING ROUTINES
// ============================================================

// -- 3D perspective floor --
function drawFloor() {
  const scrollOff = (frameCount * (speed || 1) * 2) % 60;
  for (let row = 0; row < H - HORIZON; row++) {
    const t = row / (H - HORIZON);
    const y = HORIZON + row;
    // depth fog: far rows are darker
    const brightness = Math.floor(lerp(8, 40, t * t));
    const r = brightness + Math.floor(Math.sin(lavaGlowPhase + t * 3) * 5);
    ctx.fillStyle = `rgb(${clamp(r,0,60)}, ${clamp(Math.floor(brightness*0.15),0,15)}, 0)`;
    ctx.fillRect(0, y, W, 1);

    // perspective grid lines
    if (row % 3 === 0) {
      const perspScale = t * t;
      const lineSpacing = 60 * (perspScale + 0.1);
      const xOff = ((scrollOff * perspScale * 2) % lineSpacing);
      ctx.strokeStyle = `rgba(${60 + brightness}, ${10 + Math.floor(brightness*0.3)}, 0, ${0.15 + perspScale * 0.2})`;
      ctx.lineWidth = 0.5 + perspScale;
      // Vertical grid lines converging to VP
      for (let gx = -xOff; gx < W; gx += lineSpacing) {
        const farX = lerp(gx, VP_X, 1 - t);
        ctx.beginPath();
        ctx.moveTo(gx, y);
        ctx.lineTo(gx, y + 1);
        ctx.stroke();
      }
    }
  }

  // Horizontal grid lines (rows going into distance)
  const hLineCount = 20;
  for (let i = 0; i < hLineCount; i++) {
    const rawT = ((i / hLineCount) + (scrollOff / 60) * 0.03) % 1;
    const t = rawT * rawT; // perspective compression
    const y = HORIZON + t * (H - HORIZON);
    const alpha = 0.08 + t * 0.2;
    ctx.strokeStyle = `rgba(80, 15, 0, ${alpha})`;
    ctx.lineWidth = 0.5 + t * 1.5;
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(W, y);
    ctx.stroke();
  }

  // Lava cracks (bright lines in the floor)
  ctx.globalAlpha = 0.4 + Math.sin(lavaGlowPhase) * 0.15;
  for (let i = 0; i < 5; i++) {
    const seed = i * 137.5 + Math.floor(frameCount * 0.02);
    const t = ((seed * 0.1 + scrollOff * 0.01) % 1);
    const y = HORIZON + t * t * (H - HORIZON);
    if (y < HORIZON + 5) continue;
    const x1 = (Math.sin(seed) * 0.5 + 0.5) * W;
    const x2 = x1 + Math.sin(seed * 2.3) * 80;
    const grd = ctx.createLinearGradient(x1, y, x2, y);
    grd.addColorStop(0, 'rgba(255,80,0,0)');
    grd.addColorStop(0.3, 'rgba(255,120,0,0.8)');
    grd.addColorStop(0.5, 'rgba(255,200,50,1)');
    grd.addColorStop(0.7, 'rgba(255,120,0,0.8)');
    grd.addColorStop(1, 'rgba(255,80,0,0)');
    ctx.strokeStyle = grd;
    ctx.lineWidth = 1 + t * 2;
    ctx.beginPath();
    ctx.moveTo(x1, y);
    ctx.quadraticCurveTo((x1+x2)/2, y - 3 + Math.sin(frameCount*0.05+i)*4, x2, y);
    ctx.stroke();
  }
  ctx.globalAlpha = 1;
}

// -- 3D perspective ceiling --
function drawCeiling() {
  const scrollOff = (frameCount * (speed || 1) * 2) % 60;
  for (let row = 0; row < HORIZON; row++) {
    const t = 1 - row / HORIZON; // 0=horizon, 1=top
    const brightness = Math.floor(lerp(5, 20, t * t));
    ctx.fillStyle = `rgb(${brightness}, 0, ${Math.floor(brightness * 0.3)})`;
    ctx.fillRect(0, row, W, 1);
  }
  // Stalactites
  const stalCount = 18;
  for (let i = 0; i < stalCount; i++) {
    const baseX = ((i / stalCount) * W + scrollOff * 1.5) % (W + 80) - 40;
    const h = 20 + Math.sin(i * 3.7) * 15;
    const w = 6 + Math.sin(i * 2.1) * 3;
    const grd = ctx.createLinearGradient(baseX, 0, baseX, h);
    grd.addColorStop(0, '#1a0010');
    grd.addColorStop(1, 'rgba(20,0,8,0)');
    ctx.fillStyle = grd;
    ctx.beginPath();
    ctx.moveTo(baseX - w, 0);
    ctx.lineTo(baseX, h);
    ctx.lineTo(baseX + w, 0);
    ctx.closePath();
    ctx.fill();
    // drip
    if (Math.sin(frameCount * 0.03 + i * 1.5) > 0.7) {
      ctx.fillStyle = 'rgba(200, 0, 50, 0.6)';
      const dripY = h + ((frameCount * 1.5 + i * 50) % 40);
      ctx.beginPath();
      ctx.ellipse(baseX, dripY, 1.5, 2.5, 0, 0, Math.PI * 2);
      ctx.fill();
    }
  }
}

// -- Parallax hell mountains --
function drawMountains() {
  for (let l = 0; l < mountainLayers.length; l++) {
    const layer = mountainLayers[l];
    layer.offset += speed * layer.speed;
    const colors = [
      'rgba(30, 0, 5, 0.9)',   // farthest - darkest
      'rgba(50, 5, 10, 0.8)',
      'rgba(70, 10, 5, 0.7)'   // closest
    ];
    ctx.fillStyle = colors[layer.color];
    ctx.beginPath();
    ctx.moveTo(0, HORIZON);
    for (let i = 0; i < layer.pts.length; i++) {
      const px = (layer.pts[i].x - layer.offset % (W + 60) + W + 60) % (W + 60) - 30;
      ctx.lineTo(px, layer.pts[i].y);
    }
    ctx.lineTo(W + 10, HORIZON);
    ctx.closePath();
    ctx.fill();

    // Mountain glow (lava behind mountains for far layers)
    if (l === 0) {
      const glowGrd = ctx.createLinearGradient(0, HORIZON - 80, 0, HORIZON);
      glowGrd.addColorStop(0, 'rgba(255, 40, 0, 0)');
      glowGrd.addColorStop(1, `rgba(255, 60, 0, ${0.08 + Math.sin(lavaGlowPhase * 0.5) * 0.04})`);
      ctx.fillStyle = glowGrd;
      ctx.fillRect(0, HORIZON - 80, W, 80);
    }
  }
}

// -- 3D Skull with shading --
function drawSkull3D(x, y, size, baseColor, highlight, shadowDir) {
  const r = parseInt(baseColor.slice(1,3),16), g = parseInt(baseColor.slice(3,5),16), b = parseInt(baseColor.slice(5,7),16);
  // Drop shadow
  ctx.fillStyle = 'rgba(0,0,0,0.4)';
  ctx.beginPath();
  ctx.ellipse(x + 3, y + size * 0.35, size * 0.35, size * 0.12, 0, 0, Math.PI * 2);
  ctx.fill();

  // Head - main sphere with gradient shading
  const headR = size * 0.45;
  const grd = ctx.createRadialGradient(x - headR*0.3, y - size*0.1 - headR*0.3, headR*0.1, x, y - size*0.1, headR);
  grd.addColorStop(0, `rgb(${Math.min(255,r+80)}, ${Math.min(255,g+80)}, ${Math.min(255,b+80)})`);
  grd.addColorStop(0.5, baseColor);
  grd.addColorStop(1, `rgb(${Math.floor(r*0.4)}, ${Math.floor(g*0.4)}, ${Math.floor(b*0.4)})`);
  ctx.fillStyle = grd;
  ctx.beginPath();
  ctx.arc(x, y - size * 0.1, headR, 0, Math.PI * 2);
  ctx.fill();
  // Specular highlight
  ctx.fillStyle = `rgba(255,255,255,${highlight || 0.15})`;
  ctx.beginPath();
  ctx.ellipse(x - headR*0.25, y - size*0.1 - headR*0.3, headR*0.2, headR*0.15, -0.3, 0, Math.PI*2);
  ctx.fill();

  // Jaw with 3D shading
  const jawGrd = ctx.createLinearGradient(x, y + size*0.15, x, y + size*0.4);
  jawGrd.addColorStop(0, baseColor);
  jawGrd.addColorStop(1, `rgb(${Math.floor(r*0.5)}, ${Math.floor(g*0.5)}, ${Math.floor(b*0.5)})`);
  ctx.fillStyle = jawGrd;
  ctx.beginPath();
  ctx.moveTo(x - size*0.22, y + size*0.15);
  ctx.quadraticCurveTo(x - size*0.25, y + size*0.35, x - size*0.15, y + size*0.38);
  ctx.lineTo(x + size*0.15, y + size*0.38);
  ctx.quadraticCurveTo(x + size*0.25, y + size*0.35, x + size*0.22, y + size*0.15);
  ctx.closePath();
  ctx.fill();

  // Eye sockets (deep, dark, 3D)
  const eyeR = size * 0.11;
  for (let side = -1; side <= 1; side += 2) {
    const ex = x + side * size * 0.15;
    const ey = y - size * 0.12;
    const eyeGrd = ctx.createRadialGradient(ex, ey, eyeR * 0.2, ex, ey, eyeR);
    eyeGrd.addColorStop(0, '#000');
    eyeGrd.addColorStop(0.7, '#110005');
    eyeGrd.addColorStop(1, `rgb(${Math.floor(r*0.3)}, ${Math.floor(g*0.3)}, ${Math.floor(b*0.3)})`);
    ctx.fillStyle = eyeGrd;
    ctx.beginPath();
    ctx.ellipse(ex, ey, eyeR, eyeR * 1.2, 0, 0, Math.PI * 2);
    ctx.fill();
  }

  // Nose hole
  ctx.fillStyle = '#0a0003';
  ctx.beginPath();
  ctx.moveTo(x, y + size * 0.02);
  ctx.lineTo(x - size*0.04, y + size * 0.1);
  ctx.lineTo(x + size*0.04, y + size * 0.1);
  ctx.closePath();
  ctx.fill();

  // Teeth
  ctx.fillStyle = `rgb(${Math.min(255,r+40)}, ${Math.min(255,g+40)}, ${Math.min(255,b+40)})`;
  for (let i = -2; i <= 2; i++) {
    const tx = x + i * size * 0.065;
    ctx.fillRect(tx - 2, y + size*0.15, 4, size * 0.12);
    // Tooth shadow
    ctx.fillStyle = `rgba(0,0,0,0.2)`;
    ctx.fillRect(tx - 2, y + size*0.15, 4, 2);
    ctx.fillStyle = `rgb(${Math.min(255,r+40)}, ${Math.min(255,g+40)}, ${Math.min(255,b+40)})`;
  }
}

// -- 3D Player (skeleton with depth) --
function drawPlayer() {
  if (invincible > 0 && Math.floor(frameCount / 3) % 2 === 0) return;
  const { sx, sy, scale, depth } = worldToScreen(player.x, player.y);
  const sz = 30 * scale;

  // Trail with perspective
  ctx.globalAlpha = 0.25;
  for (let i = 0; i < player.trail.length; i++) {
    const t = player.trail[i];
    const ts = worldToScreen(t.x, t.y);
    const a = (i / player.trail.length) * 0.25;
    ctx.globalAlpha = a;
    const tsz = 24 * ts.scale;
    drawSkull3D(ts.sx, ts.sy - tsz * 0.3, tsz, dashCooldown < 30 ? '#ff2233' : '#cc4400', 0.05);
  }
  ctx.globalAlpha = 1;

  // Player glow (dynamic light)
  const glowR = 60 * scale;
  const pgrd = ctx.createRadialGradient(sx, sy, 5 * scale, sx, sy, glowR);
  pgrd.addColorStop(0, 'rgba(255, 30, 60, 0.35)');
  pgrd.addColorStop(0.5, 'rgba(255, 10, 30, 0.1)');
  pgrd.addColorStop(1, 'rgba(255, 0, 20, 0)');
  ctx.fillStyle = pgrd;
  ctx.fillRect(sx - glowR, sy - glowR, glowR * 2, glowR * 2);

  // Floor reflection
  ctx.globalAlpha = 0.15;
  ctx.save();
  ctx.translate(sx, sy + sz * 1.1);
  ctx.scale(1, -0.3);
  drawSkull3D(0, 0, sz * 0.8, '#ff1122', 0.02);
  ctx.restore();
  ctx.globalAlpha = 1;

  // Body - skeleton with 3D bone shading
  const boneGrd = ctx.createLinearGradient(sx - 2, sy, sx + 2, sy + sz);
  boneGrd.addColorStop(0, '#eee');
  boneGrd.addColorStop(0.5, '#ccc');
  boneGrd.addColorStop(1, '#888');
  ctx.strokeStyle = boneGrd;
  ctx.lineWidth = 2.5 * scale;
  ctx.lineCap = 'round';

  // Spine
  ctx.beginPath();
  ctx.moveTo(sx, sy + sz * 0.25);
  ctx.lineTo(sx, sy + sz * 0.75);
  ctx.stroke();

  // Ribs
  for (let i = 0; i < 3; i++) {
    const ry = sy + sz * (0.3 + i * 0.12);
    const rw = (8 - i * 1.5) * scale;
    ctx.beginPath();
    ctx.ellipse(sx, ry, rw, 2 * scale, 0, 0, Math.PI);
    ctx.stroke();
  }

  // Arms
  const armWave = Math.sin(frameCount * 0.15) * 6 * scale;
  const lean = player.lean * scale;
  ctx.beginPath();
  ctx.moveTo(sx - 14 * scale + lean, sy + sz * 0.3 + armWave);
  ctx.quadraticCurveTo(sx - 8 * scale, sy + sz * 0.35, sx, sy + sz * 0.32);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(sx + 14 * scale + lean, sy + sz * 0.3 - armWave);
  ctx.quadraticCurveTo(sx + 8 * scale, sy + sz * 0.35, sx, sy + sz * 0.32);
  ctx.stroke();
  // Hands (small circles)
  ctx.fillStyle = '#ddd';
  ctx.beginPath();
  ctx.arc(sx - 14*scale + lean, sy + sz*0.3 + armWave, 2.5*scale, 0, Math.PI*2);
  ctx.arc(sx + 14*scale + lean, sy + sz*0.3 - armWave, 2.5*scale, 0, Math.PI*2);
  ctx.fill();

  // Legs
  const legWave = Math.sin(frameCount * 0.2) * 5 * scale;
  ctx.strokeStyle = boneGrd;
  ctx.beginPath();
  ctx.moveTo(sx - 8*scale, sy + sz + legWave);
  ctx.quadraticCurveTo(sx - 4*scale, sy + sz*0.85, sx, sy + sz*0.75);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(sx + 8*scale, sy + sz - legWave);
  ctx.quadraticCurveTo(sx + 4*scale, sy + sz*0.85, sx, sy + sz*0.75);
  ctx.stroke();
  // Feet
  ctx.fillStyle = '#bbb';
  ctx.beginPath();
  ctx.ellipse(sx - 8*scale, sy + sz + legWave, 3*scale, 1.5*scale, 0, 0, Math.PI*2);
  ctx.ellipse(sx + 8*scale, sy + sz - legWave, 3*scale, 1.5*scale, 0, 0, Math.PI*2);
  ctx.fill();

  // Skull head (3D)
  drawSkull3D(sx, sy, sz, '#eeddcc', 0.2);

  // Flame eyes
  if (dashCooldown > 0 && dashCooldown < 50) {
    for (let side = -1; side <= 1; side += 2) {
      const ex = sx + side * sz * 0.15;
      const ey = sy - sz * 0.12;
      const fgrd = ctx.createRadialGradient(ex, ey, 1, ex, ey - 4*scale, 6*scale);
      fgrd.addColorStop(0, 'rgba(255,255,100,1)');
      fgrd.addColorStop(0.4, 'rgba(255,50,0,0.8)');
      fgrd.addColorStop(1, 'rgba(255,0,0,0)');
      ctx.fillStyle = fgrd;
      ctx.fillRect(ex - 6*scale, ey - 8*scale, 12*scale, 12*scale);
    }
  }

  ctx.lineCap = 'butt';
}

// -- 3D Obstacle rendering --
function drawObstacle(o) {
  const { sx, sy, scale, depth } = worldToScreen(o.x, o.y);
  if (sx < -100 || sx > W + 100) return;
  ctx.save();

  const sw = o.w * scale;
  const sh = o.h * scale;

  switch (o.type.pattern) {
    case 'pillar': {
      // 3D pillar with depth faces
      const pw = sw, ph = sh;
      const sideW = pw * 0.3;
      // Dark side face
      ctx.fillStyle = '#660000';
      ctx.beginPath();
      ctx.moveTo(sx + pw/2, sy);
      ctx.lineTo(sx + pw/2 + sideW, sy - sideW*0.5);
      ctx.lineTo(sx + pw/2 + sideW, sy - sideW*0.5 + ph);
      ctx.lineTo(sx + pw/2, sy + ph);
      ctx.closePath();
      ctx.fill();
      // Front face gradient
      const pgrd = ctx.createLinearGradient(sx - pw/2, sy, sx + pw/2, sy);
      pgrd.addColorStop(0, '#cc2200');
      pgrd.addColorStop(0.3, '#ff4400');
      pgrd.addColorStop(0.7, '#ff3300');
      pgrd.addColorStop(1, '#991100');
      ctx.fillStyle = pgrd;
      ctx.fillRect(sx - pw/2, sy, pw, ph);
      // Top face
      ctx.fillStyle = '#ff5500';
      ctx.beginPath();
      ctx.moveTo(sx - pw/2, sy);
      ctx.lineTo(sx - pw/2 + sideW, sy - sideW*0.5);
      ctx.lineTo(sx + pw/2 + sideW, sy - sideW*0.5);
      ctx.lineTo(sx + pw/2, sy);
      ctx.closePath();
      ctx.fill();
      // Flame particles on top
      for (let i = 0; i < 8; i++) {
        const fx = sx - pw/2 + Math.random() * pw;
        const fy = sy - Math.random() * 20 * scale;
        const fr = rand(3, 8) * scale;
        const fgrd = ctx.createRadialGradient(fx, fy, 0, fx, fy, fr);
        fgrd.addColorStop(0, `rgba(255,${Math.floor(rand(180,255))},50,0.9)`);
        fgrd.addColorStop(0.5, 'rgba(255,100,0,0.4)');
        fgrd.addColorStop(1, 'rgba(255,50,0,0)');
        ctx.fillStyle = fgrd;
        ctx.beginPath();
        ctx.arc(fx, fy, fr, 0, Math.PI * 2);
        ctx.fill();
      }
      // Glow on floor
      const flGrd = ctx.createRadialGradient(sx, sy + ph, 0, sx, sy + ph, pw * 1.5);
      flGrd.addColorStop(0, 'rgba(255,60,0,0.2)');
      flGrd.addColorStop(1, 'rgba(255,30,0,0)');
      ctx.fillStyle = flGrd;
      ctx.fillRect(sx - pw*1.5, sy + ph - pw*0.5, pw*3, pw*1.5);
      break;
    }
    case 'skull': {
      // Floating demon skull with glow
      const bob = Math.sin(frameCount * 0.05 + o.sinOffset) * 5 * scale;
      const skullY = sy + bob;
      // Shadow on floor
      ctx.fillStyle = 'rgba(0,0,0,0.3)';
      ctx.beginPath();
      ctx.ellipse(sx, sy + sw * 0.6, sw * 0.4, sw * 0.1, 0, 0, Math.PI * 2);
      ctx.fill();
      // Glow aura
      const aGrd = ctx.createRadialGradient(sx, skullY, sw*0.2, sx, skullY, sw*0.8);
      aGrd.addColorStop(0, 'rgba(255,0,80,0.3)');
      aGrd.addColorStop(1, 'rgba(255,0,40,0)');
      ctx.fillStyle = aGrd;
      ctx.beginPath();
      ctx.arc(sx, skullY, sw * 0.8, 0, Math.PI * 2);
      ctx.fill();
      drawSkull3D(sx, skullY, sw, '#cc0044', 0.12);
      // Glowing eyes
      for (let side = -1; side <= 1; side += 2) {
        const ex = sx + side * sw * 0.15;
        const ey = skullY - sw * 0.12;
        const egrd = ctx.createRadialGradient(ex, ey, 0, ex, ey, 5 * scale);
        egrd.addColorStop(0, 'rgba(255,255,0,1)');
        egrd.addColorStop(0.5, 'rgba(255,200,0,0.5)');
        egrd.addColorStop(1, 'rgba(255,100,0,0)');
        ctx.fillStyle = egrd;
        ctx.beginPath();
        ctx.arc(ex, ey, 5 * scale, 0, Math.PI * 2);
        ctx.fill();
      }
      break;
    }
    case 'saw': {
      o.angle += 0.18;
      ctx.translate(sx, sy);
      ctx.rotate(o.angle);
      const sawR = 28 * scale;
      // Saw blade with metallic gradient
      const sgrd = ctx.createRadialGradient(0, 0, sawR * 0.2, 0, 0, sawR);
      sgrd.addColorStop(0, '#fff');
      sgrd.addColorStop(0.3, '#ddd');
      sgrd.addColorStop(0.6, '#999');
      sgrd.addColorStop(1, '#555');
      ctx.fillStyle = sgrd;
      ctx.beginPath();
      const teeth = 16;
      for (let i = 0; i < teeth; i++) {
        const a = (i / teeth) * Math.PI * 2;
        const r = i % 2 === 0 ? sawR : sawR * 0.72;
        ctx.lineTo(Math.cos(a) * r, Math.sin(a) * r);
      }
      ctx.closePath();
      ctx.fill();
      // Edge highlight
      ctx.strokeStyle = 'rgba(255,255,255,0.3)';
      ctx.lineWidth = 1;
      ctx.stroke();
      // Center hub
      const hgrd = ctx.createRadialGradient(0, 0, 0, 0, 0, 7 * scale);
      hgrd.addColorStop(0, '#888');
      hgrd.addColorStop(0.5, '#555');
      hgrd.addColorStop(1, '#333');
      ctx.fillStyle = hgrd;
      ctx.beginPath();
      ctx.arc(0, 0, 7 * scale, 0, Math.PI * 2);
      ctx.fill();
      // Blood splatters
      ctx.fillStyle = 'rgba(180, 0, 20, 0.6)';
      for (let i = 0; i < 5; i++) {
        const ba = rand(0, Math.PI * 2);
        const br = rand(sawR * 0.3, sawR * 0.8);
        ctx.beginPath();
        ctx.arc(Math.cos(ba) * br, Math.sin(ba) * br, rand(1, 3) * scale, 0, Math.PI * 2);
        ctx.fill();
      }
      // Motion blur ring
      ctx.strokeStyle = 'rgba(200,200,200,0.08)';
      ctx.lineWidth = sawR * 0.6;
      ctx.beginPath();
      ctx.arc(0, 0, sawR * 0.85, 0, Math.PI * 2);
      ctx.stroke();
      break;
    }
    case 'geyser': {
      // Lava geyser with volumetric spray
      const baseW = 14 * scale;
      // Ground crack
      ctx.fillStyle = '#ff4400';
      ctx.beginPath();
      ctx.ellipse(sx, sy + sh, baseW, 4 * scale, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#ffaa00';
      ctx.beginPath();
      ctx.ellipse(sx, sy + sh, baseW * 0.5, 2 * scale, 0, 0, Math.PI * 2);
      ctx.fill();
      // Spray column
      for (let row = 0; row < sh; row += 2) {
        const t = row / sh;
        const wobble = Math.sin((frameCount * 0.12 + row * 0.08) + o.sinOffset) * (8 + t * 12) * scale;
        const width = lerp(baseW, baseW * 0.3, t) * (1 + Math.sin(frameCount*0.1+row*0.05)*0.2);
        const r = Math.floor(lerp(255, 255, t));
        const g = Math.floor(lerp(200, 40, t));
        const b = Math.floor(lerp(50, 0, t));
        const alpha = lerp(0.9, 0.1, t);
        ctx.fillStyle = `rgba(${r},${g},${b},${alpha})`;
        ctx.fillRect(sx - width/2 + wobble, sy + sh - row, width, 3);
      }
      // Core brightness
      ctx.globalCompositeOperation = 'lighter';
      const cGrd = ctx.createLinearGradient(sx, sy + sh, sx, sy);
      cGrd.addColorStop(0, 'rgba(255,200,50,0.4)');
      cGrd.addColorStop(0.5, 'rgba(255,100,0,0.15)');
      cGrd.addColorStop(1, 'rgba(255,50,0,0)');
      ctx.fillStyle = cGrd;
      ctx.fillRect(sx - baseW * 0.3, sy, baseW * 0.6, sh);
      ctx.globalCompositeOperation = 'source-over';
      break;
    }
    case 'spike': {
      // 3D blood spike with shading
      const spikeW = sw;
      const spikeH = sh;
      // Shadow
      ctx.fillStyle = 'rgba(0,0,0,0.3)';
      ctx.beginPath();
      ctx.ellipse(sx, sy + spikeH, spikeW * 0.6, 3 * scale, 0, 0, Math.PI * 2);
      ctx.fill();
      // Dark side
      ctx.fillStyle = '#550011';
      ctx.beginPath();
      ctx.moveTo(sx + 2, sy);
      ctx.lineTo(sx + spikeW/2 + 2, sy + spikeH);
      ctx.lineTo(sx + spikeW/2, sy + spikeH);
      ctx.lineTo(sx, sy);
      ctx.closePath();
      ctx.fill();
      // Lit side
      const spGrd = ctx.createLinearGradient(sx - spikeW/2, sy, sx, sy);
      spGrd.addColorStop(0, '#880022');
      spGrd.addColorStop(1, '#cc0033');
      ctx.fillStyle = spGrd;
      ctx.beginPath();
      ctx.moveTo(sx, sy);
      ctx.lineTo(sx - spikeW/2, sy + spikeH);
      ctx.lineTo(sx + spikeW/2, sy + spikeH);
      ctx.closePath();
      ctx.fill();
      // Specular edge
      ctx.strokeStyle = 'rgba(255,100,100,0.3)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(sx, sy);
      ctx.lineTo(sx - spikeW * 0.15, sy + spikeH * 0.6);
      ctx.stroke();
      // Blood drip
      const dripT = ((frameCount * 2 + o.sinOffset * 100) % 80) / 80;
      const dripY = sy + dripT * spikeH;
      const dripGrd = ctx.createRadialGradient(sx, dripY, 0, sx, dripY, 4 * scale);
      dripGrd.addColorStop(0, 'rgba(200,0,20,0.8)');
      dripGrd.addColorStop(1, 'rgba(150,0,10,0)');
      ctx.fillStyle = dripGrd;
      ctx.beginPath();
      ctx.ellipse(sx, dripY, 3 * scale, 4 * scale, 0, 0, Math.PI * 2);
      ctx.fill();
      break;
    }
    case 'chain': {
      // 3D spiked chain with metallic shading
      const chainLen = o.w * scale;
      const linkSize = 8 * scale;
      ctx.lineWidth = 3 * scale;
      // Draw chain links
      for (let i = 0; i < chainLen; i += linkSize * 1.2) {
        const rawCy = Math.sin((i / scale + frameCount * 3) * 0.05) * 25 * scale;
        const cx = sx + i - chainLen/2;
        const cy = sy + rawCy;
        // Link
        const metalGrd = ctx.createLinearGradient(cx, cy - linkSize/2, cx, cy + linkSize/2);
        metalGrd.addColorStop(0, '#aaa');
        metalGrd.addColorStop(0.5, '#666');
        metalGrd.addColorStop(1, '#333');
        ctx.strokeStyle = metalGrd;
        ctx.lineWidth = 2 * scale;
        ctx.beginPath();
        ctx.ellipse(cx, cy, linkSize * 0.5, linkSize * 0.35, 0, 0, Math.PI * 2);
        ctx.stroke();
        // Spike on every other link
        if (Math.floor(i / linkSize) % 2 === 0) {
          ctx.fillStyle = '#999';
          ctx.beginPath();
          ctx.moveTo(cx, cy - linkSize * 0.7);
          ctx.lineTo(cx - 3 * scale, cy - linkSize * 0.2);
          ctx.lineTo(cx + 3 * scale, cy - linkSize * 0.2);
          ctx.closePath();
          ctx.fill();
          // Spike highlight
          ctx.fillStyle = 'rgba(255,255,255,0.15)';
          ctx.beginPath();
          ctx.moveTo(cx, cy - linkSize * 0.7);
          ctx.lineTo(cx - 1, cy - linkSize * 0.3);
          ctx.lineTo(cx + 1, cy - linkSize * 0.3);
          ctx.closePath();
          ctx.fill();
        }
      }
      break;
    }
  }
  ctx.restore();
}

// -- 3D Soul orb --
function drawSoul(s) {
  s.pulse += 0.08;
  const { sx, sy, scale } = worldToScreen(s.x, s.y);
  const baseSz = (s.size + Math.sin(s.pulse) * 3) * scale;

  // Floor reflection
  ctx.fillStyle = 'rgba(120, 0, 255, 0.08)';
  ctx.beginPath();
  ctx.ellipse(sx, sy + baseSz * 1.5, baseSz * 0.8, baseSz * 0.15, 0, 0, Math.PI * 2);
  ctx.fill();

  // Outer glow rings
  for (let ring = 3; ring > 0; ring--) {
    const rr = baseSz * (0.5 + ring * 0.4);
    const grd = ctx.createRadialGradient(sx, sy, rr * 0.3, sx, sy, rr);
    grd.addColorStop(0, `rgba(170,0,255,${0.15 / ring})`);
    grd.addColorStop(1, 'rgba(170,0,255,0)');
    ctx.fillStyle = grd;
    ctx.beginPath();
    ctx.arc(sx, sy, rr, 0, Math.PI * 2);
    ctx.fill();
  }

  // Core sphere with 3D shading
  const coreR = baseSz * 0.45;
  const cGrd = ctx.createRadialGradient(sx - coreR*0.3, sy - coreR*0.3, coreR*0.1, sx, sy, coreR);
  cGrd.addColorStop(0, '#ffffff');
  cGrd.addColorStop(0.2, '#ee88ff');
  cGrd.addColorStop(0.6, '#cc44ff');
  cGrd.addColorStop(1, '#6600aa');
  ctx.fillStyle = cGrd;
  ctx.beginPath();
  ctx.arc(sx, sy, coreR, 0, Math.PI * 2);
  ctx.fill();

  // Wispy tendrils (more detailed)
  for (let i = 0; i < 6; i++) {
    const a = (i / 6) * Math.PI * 2 + frameCount * 0.035;
    const len = baseSz * rand(0.8, 1.4);
    ctx.strokeStyle = `rgba(180, 60, 255, ${0.3 + Math.sin(frameCount * 0.1 + i) * 0.15})`;
    ctx.lineWidth = (1.5 + Math.sin(frameCount * 0.08 + i * 2) * 0.5) * scale;
    ctx.beginPath();
    ctx.moveTo(sx, sy);
    ctx.bezierCurveTo(
      sx + Math.cos(a) * len * 0.5, sy + Math.sin(a) * len * 0.5,
      sx + Math.cos(a + 0.8) * len * 0.7, sy + Math.sin(a + 0.8) * len * 0.8,
      sx + Math.cos(a + 0.4) * len * 0.3, sy + Math.sin(a + 0.3) * len
    );
    ctx.stroke();
  }
}

// ---- collision (same logic, just using raw game coords) ----
function rectCollide(ax, ay, aw, ah, bx, by, bw, bh) {
  return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
}
function getObstacleHitbox(o) {
  const t = o.type;
  switch (t.pattern) {
    case 'pillar': return { x: o.x - o.w/2, y: o.y, w: o.w, h: o.h };
    case 'skull': return { x: o.x - o.w/2, y: o.y - o.w/2, w: o.w, h: o.w };
    case 'saw': return { x: o.x - 25, y: o.y - 25, w: 50, h: 50 };
    case 'geyser': return { x: o.x - 10, y: o.y, w: 20, h: o.h };
    case 'spike': return { x: o.x - o.w/2, y: o.y, w: o.w, h: o.h };
    case 'chain':
      const cy = o.y + Math.sin((player.x - o.x + frameCount * 3) * 0.05) * 25;
      return { x: o.x - o.w/2, y: cy - 15, w: o.w, h: 30 };
    default: return { x: o.x, y: o.y, w: o.w, h: o.h };
  }
}

const COMBO_TAUNTS = ['','','NOT BAD...','UNHOLY','DEMONIC!','BLASPHEMOUS!!','SACRILEGE!!!','GODKILLER!!!!','BEYOND DEATH!!!!!'];

// ---- update ----
function update() {
  frameCount++;
  lavaGlowPhase += 0.02;
  if (state !== 'playing') { updateParticles(); return; }

  speed = 3 + distance / 300;
  if (speed > 12) speed = 12;
  distance += speed * 0.1;
  if (dashCooldown > 0) dashCooldown--;
  if (invincible > 0) invincible--;

  const moveSpeed = 5;
  const vertAccel = 0.8;
  if (keys['ArrowUp'] || keys['KeyW']) player.vy -= vertAccel;
  if (keys['ArrowDown'] || keys['KeyS']) player.vy += vertAccel;
  if (keys['ArrowLeft'] || keys['KeyA']) { player.x -= moveSpeed; player.lean = lerp(player.lean, -5, 0.15); }
  else if (keys['ArrowRight'] || keys['KeyD']) { player.x += moveSpeed; player.lean = lerp(player.lean, 5, 0.15); }
  else { player.lean = lerp(player.lean, 0, 0.1); }

  if ((keys['ShiftLeft'] || keys['ShiftRight']) && dashCooldown === 0) {
    dashCooldown = 60; invincible = 15; speed += 2; screenShake = 6;
    for (let i = 0; i < 15; i++) {
      particles.push({ x: player.x + rand(-15,15), y: player.y + rand(-10,10), vx: rand(-6,-2), vy: rand(-2,2), life: 25, maxLife: 25, size: rand(2,5), color: '#ff3300', glow: true });
    }
  }

  if (touchX !== null) {
    const targetX = (touchX / canvas.getBoundingClientRect().width) * W;
    player.x += (targetX - player.x) * 0.08;
  }

  player.vy *= 0.92;
  player.y += player.vy;
  player.x = clamp(player.x, 30, W - 30);
  if (player.y < HORIZON + 40) { player.y = HORIZON + 40; player.vy = 0; }
  if (player.y > H - 35) { player.y = H - 35; player.vy = 0; }

  player.trail.push({ x: player.x, y: player.y });
  if (player.trail.length > 8) player.trail.shift();

  const spawnRate = Math.max(28, 80 - distance / 10);
  if (frameCount - lastObstacle > spawnRate) { spawnObstacle(); lastObstacle = frameCount; }
  if (frameCount - lastSoul > 90 + Math.random() * 60) { spawnSoul(); lastSoul = frameCount; }

  // Sort obstacles by y for depth ordering
  obstacles.sort((a, b) => a.y - b.y);

  for (let i = obstacles.length - 1; i >= 0; i--) {
    const o = obstacles[i];
    o.x -= speed;
    if (o.type.pattern === 'saw' && o.vy) { o.y += o.vy; if (o.y < HORIZON + 40 || o.y > H - 30) o.vy *= -1; }
    if (o.homing) o.y += (player.y - o.y) * 0.02;
    if (invincible === 0) {
      const hb = getObstacleHitbox(o);
      if (rectCollide(player.x - 10, player.y - 14, 20, 42, hb.x, hb.y, hb.w, hb.h)) { die(o.type.name); return; }
    }
    if (!o.passed && o.x + 50 < player.x) { o.passed = true; demonsDodged++; combo++; if (combo > maxCombo) maxCombo = combo; }
    if (o.x < -280) obstacles.splice(i, 1);
  }

  for (let i = souls.length - 1; i >= 0; i--) {
    const s = souls[i]; s.x -= speed;
    const dx = player.x - s.x, dy = player.y - s.y, dist = Math.sqrt(dx*dx+dy*dy);
    if (dist < 70) { s.x += dx * 0.1; s.y += dy * 0.1; }
    if (dist < 22) {
      soulCount++; combo += 2; if (combo > maxCombo) maxCombo = combo;
      for (let j = 0; j < 16; j++) {
        const a = (j/16)*Math.PI*2;
        particles.push({ x: s.x, y: s.y, vx: Math.cos(a)*4, vy: Math.sin(a)*4, life: 30, maxLife: 30, size: rand(1.5,3.5), color: '#cc44ff', glow: true });
      }
      souls.splice(i, 1); continue;
    }
    if (s.x < -30) { souls.splice(i, 1); combo = 0; }
  }

  for (const p of bgParticles) {
    p.x -= p.speed + speed * 0.3;
    p.flicker += 0.05;
    if (p.x < 0) { p.x = W; p.y = Math.random() * H; }
  }

  // Ambient fire particles from floor
  if (frameCount % 3 === 0) {
    particles.push({ x: rand(0, W), y: H - rand(0, 10), vx: rand(-0.5, 0.5), vy: rand(-2, -0.5), life: rand(30, 60), maxLife: 60, size: rand(1, 3), color: Math.random() > 0.5 ? '#ff4400' : '#ff8800', glow: true });
  }

  updateParticles();

  document.getElementById('hud-dist').textContent = Math.floor(distance);
  document.getElementById('hud-souls').textContent = soulCount;
  document.getElementById('hud-speed').textContent = speed.toFixed(1);
  const ci = Math.min(combo, COMBO_TAUNTS.length - 1);
  if (COMBO_TAUNTS[ci]) { document.getElementById('combo-text').textContent = combo + 'x ' + COMBO_TAUNTS[ci]; document.getElementById('combo-display').style.opacity = '1'; }
  else { document.getElementById('combo-display').style.opacity = '0'; }
}

function updateParticles() {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx; p.y += p.vy;
    if (p.gravity) p.vy += 0.15;
    p.vx *= 0.97; p.vy *= 0.97;
    p.life--;
    if (p.life <= 0) particles.splice(i, 1);
  }
  if (screenShake > 0) screenShake *= 0.85;
  if (screenShake < 0.5) screenShake = 0;
  if (flashAlpha > 0) flashAlpha -= 0.04;
}

// ---- draw ----
function draw() {
  ctx.save();
  if (screenShake > 0) ctx.translate((Math.random()-0.5)*screenShake, (Math.random()-0.5)*screenShake);

  // Sky gradient (hellish)
  const skyGrd = ctx.createLinearGradient(0, 0, 0, HORIZON);
  skyGrd.addColorStop(0, '#050002');
  skyGrd.addColorStop(0.4, '#0d0008');
  skyGrd.addColorStop(0.7, '#1a0010');
  skyGrd.addColorStop(1, '#2a0505');
  ctx.fillStyle = skyGrd;
  ctx.fillRect(0, 0, W, HORIZON);

  // Distant fire glow on horizon
  const hGrd = ctx.createRadialGradient(W/2, HORIZON, 50, W/2, HORIZON, W * 0.6);
  hGrd.addColorStop(0, `rgba(255, 50, 0, ${0.15 + Math.sin(lavaGlowPhase) * 0.05})`);
  hGrd.addColorStop(0.5, 'rgba(200, 20, 0, 0.05)');
  hGrd.addColorStop(1, 'rgba(100, 0, 0, 0)');
  ctx.fillStyle = hGrd;
  ctx.fillRect(0, HORIZON - 100, W, 200);

  // Mountains (parallax)
  drawMountains();

  // Ceiling with 3D perspective
  drawCeiling();

  // Floor with 3D perspective grid
  drawFloor();

  // BG embers/ash particles
  if (bgParticles) {
    for (const p of bgParticles) {
      const flick = 0.5 + Math.sin(p.flicker + frameCount * 0.05) * 0.3;
      const alpha = p.alpha * flick;
      ctx.fillStyle = `rgba(255, ${Math.floor(50 + p.z * 100)}, 0, ${alpha})`;
      const sz = p.size * (0.5 + p.z * 0.5);
      // Give embers a soft glow
      const egrd = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, sz * 2);
      egrd.addColorStop(0, `rgba(255, ${Math.floor(80 + p.z * 120)}, 0, ${alpha})`);
      egrd.addColorStop(1, 'rgba(255, 50, 0, 0)');
      ctx.fillStyle = egrd;
      ctx.beginPath();
      ctx.arc(p.x, p.y, sz * 2, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // Draw game objects sorted by depth (y position)
  // Collect all drawable objects
  const drawables = [];
  if (obstacles) for (const o of obstacles) drawables.push({ type: 'obstacle', obj: o, y: o.y });
  if (souls) for (const s of souls) drawables.push({ type: 'soul', obj: s, y: s.y });
  if (state === 'playing') drawables.push({ type: 'player', obj: player, y: player.y });

  // Sort by y (far objects first)
  drawables.sort((a, b) => a.y - b.y);

  for (const d of drawables) {
    if (d.type === 'obstacle') drawObstacle(d.obj);
    else if (d.type === 'soul') drawSoul(d.obj);
    else if (d.type === 'player') drawPlayer();
  }

  // Particles with glow
  for (const p of particles) {
    const alpha = p.life / p.maxLife;
    ctx.globalAlpha = alpha;
    if (p.glow) {
      const pgrd = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size * 2);
      pgrd.addColorStop(0, p.color);
      pgrd.addColorStop(1, p.color.slice(0,7) + '00');
      ctx.fillStyle = pgrd;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size * 2, 0, Math.PI * 2);
      ctx.fill();
    } else {
      ctx.fillStyle = p.color;
      ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);
    }
  }
  ctx.globalAlpha = 1;

  // Death flash
  if (flashAlpha > 0) {
    ctx.fillStyle = `rgba(255, 0, 0, ${flashAlpha})`;
    ctx.fillRect(0, 0, W, H);
  }

  // Volumetric fog at horizon
  const fogGrd = ctx.createLinearGradient(0, HORIZON - 30, 0, HORIZON + 60);
  fogGrd.addColorStop(0, 'rgba(40, 5, 0, 0)');
  fogGrd.addColorStop(0.4, 'rgba(30, 3, 0, 0.35)');
  fogGrd.addColorStop(0.7, 'rgba(20, 2, 0, 0.15)');
  fogGrd.addColorStop(1, 'rgba(10, 0, 0, 0)');
  ctx.fillStyle = fogGrd;
  ctx.fillRect(0, HORIZON - 30, W, 90);

  // Vignette (stronger, more cinematic)
  const vgrd = ctx.createRadialGradient(W/2, H/2, H * 0.25, W/2, H/2, H * 0.75);
  vgrd.addColorStop(0, 'rgba(0,0,0,0)');
  vgrd.addColorStop(0.6, 'rgba(0,0,0,0.15)');
  vgrd.addColorStop(1, 'rgba(0,0,0,0.75)');
  ctx.fillStyle = vgrd;
  ctx.fillRect(0, 0, W, H);

  // Chromatic aberration-style edge tint
  ctx.fillStyle = 'rgba(255, 0, 50, 0.03)';
  ctx.fillRect(0, 0, 3, H);
  ctx.fillRect(W - 3, 0, 3, H);
  ctx.fillStyle = 'rgba(0, 50, 255, 0.03)';
  ctx.fillRect(3, 0, 2, H);
  ctx.fillRect(W - 5, 0, 2, H);

  // Scanlines (subtle)
  ctx.fillStyle = 'rgba(0,0,0,0.06)';
  for (let y = 0; y < H; y += 3) ctx.fillRect(0, y, W, 1);

  // Film grain
  ctx.globalAlpha = 0.03;
  for (let i = 0; i < 60; i++) {
    const v = Math.floor(Math.random() * 255);
    ctx.fillStyle = `rgb(${v},${v},${v})`;
    ctx.fillRect(Math.random() * W, Math.random() * H, 2, 2);
  }
  ctx.globalAlpha = 1;

  ctx.restore();
}

// ---- bloom pass ----
function drawBloom() {
  bctx.clearRect(0, 0, W, H);
  // Draw bright elements to bloom buffer
  bctx.filter = 'blur(8px)';
  bctx.globalAlpha = 0.4;

  // Player glow
  if (state === 'playing' && player) {
    const { sx, sy, scale } = worldToScreen(player.x, player.y);
    const r = 40 * scale;
    bctx.fillStyle = 'rgba(255, 30, 50, 0.5)';
    bctx.beginPath();
    bctx.arc(sx, sy, r, 0, Math.PI * 2);
    bctx.fill();
  }

  // Obstacle glows
  if (obstacles) {
    for (const o of obstacles) {
      const { sx, sy, scale } = worldToScreen(o.x, o.y);
      if (sx < -50 || sx > W + 50) continue;
      if (o.type.pattern === 'pillar' || o.type.pattern === 'geyser') {
        bctx.fillStyle = 'rgba(255, 80, 0, 0.3)';
        bctx.beginPath();
        bctx.arc(sx, sy, 40 * scale, 0, Math.PI * 2);
        bctx.fill();
      } else if (o.type.pattern === 'skull') {
        bctx.fillStyle = 'rgba(255, 0, 60, 0.3)';
        bctx.beginPath();
        bctx.arc(sx, sy, 30 * scale, 0, Math.PI * 2);
        bctx.fill();
      }
    }
  }

  // Soul glows
  if (souls) {
    for (const s of souls) {
      const { sx, sy, scale } = worldToScreen(s.x, s.y);
      bctx.fillStyle = 'rgba(170, 0, 255, 0.5)';
      bctx.beginPath();
      bctx.arc(sx, sy, 25 * scale, 0, Math.PI * 2);
      bctx.fill();
    }
  }

  // Lava glow at bottom
  bctx.fillStyle = `rgba(255, 40, 0, ${0.1 + Math.sin(lavaGlowPhase) * 0.05})`;
  bctx.fillRect(0, H - 60, W, 60);

  // Horizon glow
  bctx.fillStyle = 'rgba(255, 30, 0, 0.08)';
  bctx.fillRect(0, HORIZON - 20, W, 40);

  bctx.filter = 'none';
  bctx.globalAlpha = 1;
}

// ---- title ----
function drawTitleBG() {
  // Draw the full 3D environment as title backdrop
  lavaGlowPhase += 0.02;
  frameCount++;

  ctx.save();
  const skyGrd = ctx.createLinearGradient(0, 0, 0, HORIZON);
  skyGrd.addColorStop(0, '#050002');
  skyGrd.addColorStop(0.5, '#0d0008');
  skyGrd.addColorStop(1, '#2a0505');
  ctx.fillStyle = skyGrd;
  ctx.fillRect(0, 0, W, HORIZON);

  const hGrd = ctx.createRadialGradient(W/2, HORIZON, 50, W/2, HORIZON, W*0.5);
  hGrd.addColorStop(0, `rgba(255,50,0,${0.2+Math.sin(lavaGlowPhase)*0.08})`);
  hGrd.addColorStop(1, 'rgba(100,0,0,0)');
  ctx.fillStyle = hGrd;
  ctx.fillRect(0, HORIZON-80, W, 160);

  drawMountains();
  drawCeiling();
  drawFloor();

  // Floating skulls
  ctx.globalAlpha = 0.12;
  const t = Date.now() * 0.001;
  for (let i = 0; i < 6; i++) {
    const sx = (W * (i/6) + t * 20) % (W+80) - 40;
    const sy = HORIZON + 80 + Math.sin(t + i*1.5) * 80;
    const s = worldToScreen(sx, sy);
    drawSkull3D(s.sx, s.sy, 40 * s.scale, '#ff0033', 0.05);
  }
  ctx.globalAlpha = 1;

  // Vignette
  const vgrd = ctx.createRadialGradient(W/2, H/2, 80, W/2, H/2, H*0.7);
  vgrd.addColorStop(0, 'rgba(0,0,0,0)');
  vgrd.addColorStop(1, 'rgba(0,0,0,0.85)');
  ctx.fillStyle = vgrd;
  ctx.fillRect(0, 0, W, H);

  ctx.fillStyle = 'rgba(0,0,0,0.06)';
  for (let y = 0; y < H; y += 3) ctx.fillRect(0, y, W, 1);

  ctx.restore();

  // Bloom for title
  bctx.clearRect(0, 0, W, H);
  bctx.filter = 'blur(12px)';
  bctx.globalAlpha = 0.3;
  bctx.fillStyle = 'rgba(255,40,0,0.15)';
  bctx.fillRect(0, H-80, W, 80);
  bctx.fillStyle = 'rgba(255,30,0,0.1)';
  bctx.fillRect(0, HORIZON-20, W, 40);
  bctx.filter = 'none';
  bctx.globalAlpha = 1;

  // Update mountains
  for (const layer of mountainLayers) layer.offset += 0.3;
}

// ---- main loop ----
function gameLoop() {
  if (state === 'title') {
    drawTitleBG();
  } else {
    update();
    draw();
    drawBloom();
  }
  requestAnimationFrame(gameLoop);
}

gameLoop();
</script>
</body>
</html>
